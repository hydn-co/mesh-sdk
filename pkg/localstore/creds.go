package localstore

import (
	"encoding/json"
	"fmt"
	"os"

	"github.com/google/uuid"
	"github.com/hydn-co/mesh-sdk/pkg/env"
	"github.com/hydn-co/mesh-sdk/pkg/secrets"
	"github.com/nats-io/nkeys"
)

// ClientCredentials represents locally stored credentials for a tenant.
//
// ClientID is the UUID assigned to the client, ClientSecret is a
// hex-encoded token generated by the SDK, and User is the nkeys
// KeyPair created from the stored seed.
type ClientCredentials struct {
	ClientID     uuid.UUID
	ClientSecret string
	User         nkeys.KeyPair
}

type credsFile struct {
	ClientID     uuid.UUID `json:"client_id"`
	ClientSecret string    `json:"client_secret"`
	Seed         []byte    `json:"seed"`
}

// LoadOrCreateCreds ensures a single creds file is safely created and loaded.
// It first attempts to read credentials from environment variables and falls
// back to a tenant-scoped file. The function acquires a simple file-based
// lock during creation to avoid races between concurrent processes.
//
// Environment variables used: MESH_CLIENT_ID, MESH_CLIENT_SECRET, MESH_SEED
func LoadOrCreateCreds(tenantID uuid.UUID) (ClientCredentials, error) {
	if creds, ok := tryLoadFromEnv(); ok {
		return creds, nil
	}

	path, err := GetCredsPath(tenantID)
	if err != nil {
		return ClientCredentials{}, fmt.Errorf("get creds path: %w", err)
	}
	lockPath := path + ".lock"

	if err := AcquireFileLock(lockPath); err != nil {
		return ClientCredentials{}, err
	}
	defer os.Remove(lockPath)

	creds, err := tryLoadFromFile(path)
	if err == nil {
		return creds, nil
	}

	_ = os.Remove(path) // corrupted or invalid
	return createAndStoreCreds(path)
}

func tryLoadFromEnv() (ClientCredentials, bool) {
	clientID, okID := env.TryGetEnvUUID(env.MeshClientID)
	clientSecret, okSecret := env.TryGetEnvStr(env.MeshClientSecret)
	if !okID || !okSecret {
		return ClientCredentials{}, false
	}
	// Require an explicit seed when loading credentials from environment.
	// If MESH_SEED is not provided or invalid, treat env loading as absent
	// so the caller will fall back to file-based credentials.
	if seedStr, ok := env.TryGetEnvStr(env.MeshClientSeed); ok {
		// nkeys seed is typically a printable ASCII value. We accept
		// the raw env string here; callers should provide the seed as
		// produced by KeyPair.Seed(). If you store seeds encoded in
		// hex/base64, decode before calling FromSeed.
		user, err := nkeys.FromSeed([]byte(seedStr))
		if err != nil {
			return ClientCredentials{}, false
		}
		return ClientCredentials{
			ClientID:     clientID,
			ClientSecret: clientSecret,
			User:         user,
		}, true
	}

	return ClientCredentials{}, false
}

func tryLoadFromFile(path string) (ClientCredentials, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return ClientCredentials{}, fmt.Errorf("read creds file %s: %w", path, err)
	}

	var creds credsFile
	if err := json.Unmarshal(data, &creds); err != nil {
		return ClientCredentials{}, fmt.Errorf("unmarshal creds file %s: %w", path, err)
	}

	user, err := nkeys.FromSeed(creds.Seed)
	if err != nil {
		return ClientCredentials{}, fmt.Errorf("invalid seed in creds file %s: %w", path, err)
	}

	return ClientCredentials{
		ClientID:     creds.ClientID,
		ClientSecret: creds.ClientSecret,
		User:         user,
	}, nil
}

func createAndStoreCreds(path string) (ClientCredentials, error) {
	user, err := nkeys.CreateUser()
	if err != nil {
		return ClientCredentials{}, err
	}

	seed, err := user.Seed()
	if err != nil {
		return ClientCredentials{}, fmt.Errorf("seed user: %w", err)
	}

	creds := credsFile{
		ClientID:     uuid.New(),
		ClientSecret: secrets.GenerateToken(),
		Seed:         seed,
	}

	data, err := json.MarshalIndent(creds, "", "  ")
	if err != nil {
		return ClientCredentials{}, fmt.Errorf("marshal creds: %w", err)
	}

	if err := os.WriteFile(path, data, 0600); err != nil {
		return ClientCredentials{}, fmt.Errorf("write creds file %s: %w", path, err)
	}

	return ClientCredentials{
		ClientID:     creds.ClientID,
		ClientSecret: creds.ClientSecret,
		User:         user,
	}, nil
}
